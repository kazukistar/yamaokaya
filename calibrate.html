<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Calibrate</title>
  <meta name="theme-color" content="#000000">
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;-webkit-user-select:none;user-select:none}
    #img{
      position:fixed;
      left:calc(0px - env(safe-area-inset-left));
      top:calc(0px - env(safe-area-inset-top));
      width:calc(100vw + env(safe-area-inset-left) + env(safe-area-inset-right));
      height:calc(100vh + env(safe-area-inset-top) + env(safe-area-inset-bottom));
      object-fit:cover;
      touch-action:none;
    }
    .box{position:fixed;border:2px solid rgba(0,255,255,.9);background:rgba(0,255,255,.15)}
    .h{position:absolute;width:14px;height:14px;background:rgba(0,255,255,.95);border-radius:3px}
    .h.tl{left:-7px;top:-7px} .h.tr{right:-7px;top:-7px}
    .h.bl{left:-7px;bottom:-7px} .h.br{right:-7px;bottom:-7px}
    .ui{position:fixed;left:8px;right:8px;bottom:8px;display:flex;gap:8px;justify-content:space-between;align-items:center}
    .btn{background:rgba(255,255,255,.12);color:#fff;border:1px solid rgba(255,255,255,.3);padding:10px 14px;border-radius:12px;font:16px/1.2 system-ui}
    .btn:active{transform:scale(.98)}
    .pill{position:fixed;left:8px;top:8px;color:#fff;background:rgba(0,0,0,.35);font:14px/1.2 system-ui;padding:6px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.25)}
    .code{position:fixed;right:8px;top:8px;max-width:60vw;background:rgba(0,0,0,.45);color:#0ff;border:1px solid rgba(0,255,255,.4);padding:6px 8px;border-radius:10px;font:12px/1.3 ui-monospace}
  </style>
</head>
<body>
  <img id="img" src="./images/1.jpg" />
  <div class="pill" id="info"></div>
  <pre class="code" id="code"></pre>
  <div class="ui">
    <button class="btn" id="prev">←</button>
    <button class="btn" id="add">＋ 矩形</button>
    <button class="btn" id="save">保存</button>
    <button class="btn" id="next">→</button>
    <button class="btn" id="back">戻る</button>
  </div>

  <script>
    // === 設定 ===
    const IMAGE_COUNT = 4; // ← 枚数に合わせて
    const IMAGES = Array.from({length: IMAGE_COUNT}, (_,i)=>`./images/${i+1}.jpg`);

    // 保存先キー
    const KEY = 'tapnext.hotspots';

    // 読み込み（なければ空）
    const store = JSON.parse(localStorage.getItem(KEY) || '{}');

    let index = 0; // 0=1.jpg
    const imgEl = document.getElementById('img');
    const info  = document.getElementById('info');
    const code  = document.getElementById('code');

    function clamp(i){ return (i+IMAGES.length)%IMAGES.length; }
    function show(){
      imgEl.src = IMAGES[index];
      renderBoxes();
      updateInfo();
      renderCode();
    }

    function getDispRect(){
      const vw=innerWidth, vh=innerHeight;
      const iw=imgEl.naturalWidth||1, ih=imgEl.naturalHeight||1;
      const s=Math.max(vw/iw, vh/ih);
      const dw=iw*s, dh=ih*s, dx=(vw-dw)/2, dy=(vh-dh)/2;
      return {x:dx,y:dy,w:dw,h:dh};
    }
    function imgToScreen(r){
      const R=getDispRect();
      const L=R.x+(r.x/100)*R.w, T=R.y+(r.y/100)*R.h;
      const W=(r.w/100)*R.w, H=(r.h/100)*R.h;
      return {L,T,W,H};
    }
    function screenToImgRect(L,T,W,H){
      const R=getDispRect();
      const x=( (L-R.x)/R.w )*100;
      const y=( (T-R.y)/R.h )*100;
      const w=( W/R.w )*100;
      const h=( H/R.h )*100;
      return {x:fix(x),y:fix(y),w:fix(w),h:fix(h)};
    }
    function fix(v){ return Math.max(0, Math.min(100, +v.toFixed(2))); }

    function list(){ return store[index] || (store[index]=[]); }

    function renderBoxes(){
      document.querySelectorAll('.box').forEach(n=>n.remove());
      for(const r of list()){
        const s = imgToScreen(r);
        const el = document.createElement('div');
        el.className='box';
        el.style.left = s.L+'px';
        el.style.top  = s.T+'px';
        el.style.width  = s.W+'px';
        el.style.height = s.H+'px';
        addHandles(el, r);
        document.body.appendChild(el);
      }
    }

    function addHandles(el, r){
      const mk = cls => { const h=document.createElement('div'); h.className='h '+cls; el.appendChild(h); return h; };
      const tl=mk('tl'), tr=mk('tr'), bl=mk('bl'), br=mk('br');

      // 移動
      let ox=0, oy=0, startL=0, startT=0;
      const dragStart = (cx,cy)=>{
        const rect = el.getBoundingClientRect();
        ox=cx; oy=cy; startL=rect.left; startT=rect.top;
      };
      const dragMove = (cx,cy)=>{
        const L=startL+(cx-ox), T=startT+(cy-oy);
        const W=el.getBoundingClientRect().width, H=el.getBoundingClientRect().height;
        Object.assign(r, screenToImgRect(L,T,W,H));
        renderBoxes(); renderCode(); updateInfo();
      };

      el.addEventListener('mousedown', e=>{ if(e.target.classList.contains('h'))return; dragStart(e.clientX,e.clientY); const mv=e2=>dragMove(e2.clientX,e2.clientY); const up=()=>{removeEventListener('mousemove',mv);removeEventListener('mouseup',up)}; addEventListener('mousemove',mv); addEventListener('mouseup',up); });
      el.addEventListener('touchstart', e=>{ if(e.target.classList.contains('h'))return; const t=e.changedTouches[0]; dragStart(t.clientX,t.clientY); const mv=e2=>{const tt=e2.changedTouches[0]; dragMove(tt.clientX,tt.clientY)}; const up=()=>{removeEventListener('touchmove',mv);removeEventListener('touchend',up)}; addEventListener('touchmove',mv,{passive:false}); addEventListener('touchend',up); }, {passive:true});

      // リサイズ
      const resizer = (corner) => (cx,cy)=>{
        const rect = el.getBoundingClientRect();
        let L=rect.left, T=rect.top, W=rect.width, H=rect.height;
        const dx=cx-rect.left, dy=cy-rect.top;
        if(corner==='tl'){ L=cx; T=cy; W=rect.right-cx; H=rect.bottom-cy; }
        if(corner==='tr'){ T=cy; W=cx-rect.left; H=rect.bottom-cy; }
        if(corner==='bl'){ L=cx; W=rect.right-cx; H=cy-rect.top; }
        if(corner==='br'){ W=cx-rect.left; H=cy-rect.top; }
        Object.assign(r, screenToImgRect(L,T,W,H));
        renderBoxes(); renderCode(); updateInfo();
      };
      const bind = (node, corner)=>{
        node.addEventListener('mousedown', e=>{
          e.stopPropagation(); const mv=e2=>resizer(corner)(e2.clientX,e2.clientY);
          const up=()=>{removeEventListener('mousemove',mv);removeEventListener('mouseup',up)};
          addEventListener('mousemove',mv); addEventListener('mouseup',up);
        });
        node.addEventListener('touchstart', e=>{
          e.stopPropagation(); const mv=e2=>{const t=e2.changedTouches[0]; resizer(corner)(t.clientX,t.clientY)};
          const up=()=>{removeEventListener('touchmove',mv);removeEventListener('touchend',up)};
          addEventListener('touchmove',mv,{passive:false}); addEventListener('touchend',up);
        }, {passive:true});
      };
      bind(tl,'tl'); bind(tr,'tr'); bind(bl,'bl'); bind(br,'br');
    }

    function updateInfo(){
      info.textContent = `${index+1}/${IMAGE_COUNT}  矩形:${list().length}`;
    }
    function renderCode(){
      code.textContent = JSON.stringify(store, null, 2);
    }

    // 追加・保存・移動
    document.getElementById('add').onclick = ()=>{
      // 画面中央に横長矩形を仮置き
      const R=getDispRect();
      const L=R.x+R.w*0.1, W=R.w*0.8, H=R.h*0.12, T=R.y+R.h*0.62;
      list().push( screenToImgRect(L,T,W,H) );
      renderBoxes(); renderCode(); updateInfo();
    };
    document.getElementById('save').onclick = ()=>{
      localStorage.setItem(KEY, JSON.stringify(store));
      // クリップボードにも（各ブラウザで許可必要）
      navigator.clipboard?.writeText(JSON.stringify(store));
    };
    document.getElementById('prev').onclick = ()=>{ index=clamp(index-1); show(); };
    document.getElementById('next').onclick = ()=>{ index=clamp(index+1); show(); };
    document.getElementById('back').onclick = ()=>{ location.href='./index.html'; };

    // 画像読み込み後に再配置
    imgEl.addEventListener('load', renderBoxes);

    // 初期表示
    show();
  </script>
</body>
</html>
